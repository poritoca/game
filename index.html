<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>◯戦後に死ぬ戦士</title>
	
<style>
@keyframes glowBorder {
  0% {
    box-shadow: 0 0 10px white, 0 0 5px rgba(255,255,255,0.6);
    border-color: white;
  }
  50% {
    box-shadow: 
      0 0 20px white,
      0 0 40px rgba(255, 0, 255, 0.5),
      0 0 60px rgba(0, 255, 255, 0.5),
      0 0 30px rgba(255, 255, 0, 0.4);
    border-image: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet) 1;
    border-color: transparent;
  }
  100% {
    box-shadow: 0 0 10px white, 0 0 5px rgba(255,255,255,0.6);
    border-color: white;
  }
}

#faceItemGlowFrame {
  animation: glowBorder 5s ease-in-out infinite;
  border-radius: 8px;
  pointer-events: none;
}


#loadLocalBtn.highlight, #loadLocalProgressBtn.highlight {
  animation: pulse 1.2s infinite;
  background-color: #ffcc00;
  color: #000;
  font-weight: bold;
  box-shadow: 0 0 15px #ffcc00;
  border: 2px solid #ffaa00;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.85; }
  100% { transform: scale(1); opacity: 1; }
}

</style>
	
	
  <link rel="stylesheet" href="style.css?v=3" />
	
	<script>
let IMAGE_LIST_BY_RANK = {};

async function loadFaceManifest() {
  try {
    const response = await fetch('face/faceManifest.json');
    if (!response.ok) throw new Error(`HTTP error ${response.status}`);
    const data = await response.json();
    IMAGE_LIST_BY_RANK = data;
    //console.log('Face manifest loaded:', IMAGE_LIST_BY_RANK);
  } catch (error) {
    console.error('Failed to load face manifest:', error);
    // フォールバック処理：JSON読み込み失敗時はデフォルトまたは空のリストを設定
    IMAGE_LIST_BY_RANK = { S: [], A: [], B: [], C: [], D: [] };
  }
}

// DOMContentLoaded イベントでJSON読み込みを実行 [oai_citation:1‡developer.mozilla.org](https://developer.mozilla.org/ja/docs/Web/API/Document/DOMContentLoaded_event#:~:text=document.addEventListener%28,)
window.addEventListener('DOMContentLoaded', loadFaceManifest);
</script>

</head>

<body>
	
	
	
<!-- ゲーム画面右上：戦闘状態表示エリア -->
<!-- ゲーム画面右上：戦闘状態表示エリア -->
<div id="remainingBattlesDisplay" class="battle-status-display" style="display: none;">
  残り戦闘数：◯回<br>
  現在の連勝数：◯<br>
  現在挑戦中の最大連勝数：◯
</div>
	
<div id="scoreOverlay" style="display: none;"></div>

<img id="faceOverlay" class="hidden">


<div id="skillOverlay" style="display: none;"></div>
	
  <!-- カスタムアラート -->
  <div id="customAlertContainer" style="position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
    z-index: 9999; pointer-events: none;"></div>

  <!-- タイトル画面 -->
  <div id="titleScreen">
		
<h1 id="animatedTitle">◯戦後に<span id="deathChar">死</span>ぬ戦士</h1>

<div id="titleImage" style="text-align: center; margin-bottom: 20px;">
  <img src="dark_knight.png" style="width:80%; max-width:400px; height:auto;" />
</div>
<!-- 更新情報オーバーレイ
<div id="updateNotice" style="
  position: fixed;
  top: 30%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90%;
  max-width: 400px;
  padding: 16px 20px;
  font-size: 16px;
  font-weight: bold;
  color: #fff8f0;
  text-align: center;
  background: linear-gradient(145deg, rgba(255, 100, 100, 0.35), rgba(255, 180, 120, 0.25));
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 16px;
  backdrop-filter: blur(8px);
  box-shadow: 0 0 25px rgba(255, 150, 100, 0.7);
  text-shadow: 0 0 6px rgba(255, 180, 130, 0.8);
  opacity: 1;
  transition: opacity 1s ease, transform 1s ease;
  z-index: 1000;
  cursor: pointer;
">
  🔔 更新情報：不具合を修正しました。
</div>
 -->
		
		<small class="playerNameHint">※名前により戦士の色やスキルが変化します</small>
<input type="text" id="inputStr" placeholder="はじめから時のみ名前を入力:" />

		<!-- タイトル画面の入力フォーム内（プレイヤー名入力や開始ボタン付近）に追加 -->
<select id="battleCountSelect" class="rainbow-select">
  <option value="100">100</option>
  <option value="200" selected>200</option>
  <option value="500">500</option>
  <option value="1000">1000</option>
  <option value="5000">5000</option>
  <option value="10000">10000</option>
  <option value="unlimited">無制限</option>
</select>
<div id="battleEffectOverlay"></div>

  <small>（ゲーム終了までの戦闘数を選択）</small>
	
    <button id="startNewGameBtn">はじめから</button>
  <!--   <button id="loadGameBtn">つづきから</button> -->
		

<button id="continueBtn" class="continue-btn" type="button">つづきから</button>

<div id="loadPanel" class="load-panel is-collapsed" aria-hidden="true">
	

  <div class="load-panel-inner">
		
		
		
		<small>（戦闘数を選択後、以下から選択）</small>
		
<select id="battleCountSelectB" class="rainbow-select">
  <option value="100">100</option>
  <option value="200" selected>200</option>
  <option value="500">500</option>
  <option value="1000">1000</option>
  <option value="5000">5000</option>
  <option value="10000">10000</option>
  <option value="unlimited">無制限</option>
</select>

<div id="battleEffectOverlay"></div>
    <div class="load-panel-grid" role="group" aria-label="ロード方法を選択">
			
      <button id="loadLocalBtn" class="load-tile" onclick="loadFromLocalStorage()" type="button">
        <span class="tile-title">ローカル</span>
        <span class="tile-sub">端末に保存したデータ</span>
      </button>

      <button id="loadLocalProgressBtn" class="load-tile" onclick="loadProgressFromLocalStorageCompat()" type="button">
        <span class="tile-title">中断</span>
        <span class="tile-sub">戦闘数進捗も含む</span>
      </button>

      <button id="loadFromTextBtn" class="load-tile load-tile-wide" type="button">
        <span class="tile-title">テキスト</span>
        <span class="tile-sub">保存テキスト/ファイル</span>
      </button>
    </div>
  </div>
</div>

<input type="file" id="loadTextFileInput" accept=".txt" style="display:none" />

  <!--    <div id="loadSection">
      <textarea id="saveData" rows="4" placeholder="セーブデータを入力"></textarea><br />
      <input type="file" id="saveFileInput" accept=".txt" /><br />
    </div> -->

		
  </div>

  <!-- ゲーム画面 -->
	<div id="gameScreen" class="hidden" style="margin: 50px 0;">
		<!-- 上部：4つの折りたたみを2列パネルに集約（同時に1つだけ開く） -->
			<div class="top-fold-panel" role="group" aria-label="表示切替">
				<button class="top-fold-btn" type="button" data-kind="guide" onclick="toggleTopFold('guide')">【遊び方】</button>
				<button class="top-fold-btn" type="button" data-kind="char" onclick="toggleTopFold('char')">【キャラクター情報】</button>
				<button class="top-fold-btn" type="button" data-kind="log" onclick="toggleTopFold('log')">【戦闘ログ】</button>
				<button class="top-fold-btn" type="button" data-kind="memory" onclick="toggleTopFold('memory')">【魔道具・スキル】</button>
				<button class="top-fold-btn" type="button" data-kind="event" onclick="toggleTopFold('event')">【イベント&入手設定】</button>
				<button class="top-fold-btn" type="button" data-kind="settings" onclick="toggleTopFold('settings')">【設定】</button>
			</div>

		<!-- クイックガイド -->
		<div class="quick-guide-wrapper">
			<div id="quickGuideContent" class="quick-guide-content hidden">

    <h3>このゲームの目的</h3>
    <p>
        本作の目的は、連勝数をできる限り伸ばすことです。戦闘に勝利するたびにキャラクターが成長し、新たなスキルを習得して強くなります。高い連勝記録やハイスコアの更新を目指しましょう。
    </p>

    <h3>戦闘について</h3>
    <p>
        戦闘はターン制で進行し、プレイヤーと敵が交互にスキルを使用し合います。相手のHPを0にすると勝利です。所持スキルの中から自動的に複数のスキルが選出され同時に発動します（必ず固有スキルが最低1つと、攻撃スキルが最低1つ含まれます）。
    </p>

    <h3>ボス戦について</h3>
    <p>
        一定回数ごとに<strong>ボス戦</strong>が発生します。
    <details class="guide-fold" open>
      <summary>ボス戦の概要（動的表示）</summary>
      <div class="guide-fold-body">
        <ul class="guide-list">
          <li>ボス戦の発生間隔：<strong><span id="guideBossInterval2">-</span>戦ごと</strong></li>
          <li>ボス強化倍率（通常モード）：<code><span id="guideBossMulNormal">-</span></code></li>
          <li>ボス強化倍率（鬼畜モード）：<code><span id="guideBossMulBrutal">-</span></code></li>
          <li>ボスの見た目レアリティ（連勝数で変化）：<span id="guideBossFaceRarityRule">-</span></li>
        </ul>
        <div class="subnote">※上記は <code>game.js</code> の実装値をそのまま表示しています（調整したらここも自動で変わります）。</div>
      </div>
    </details>

    <details class="guide-fold">
      <summary>ボス報酬（通常/鬼畜の確率・候補）</summary>
      <div class="guide-fold-body">
        <p class="guide-paragraph">
          ボスに勝つと、<strong>魔道具（ボス戦利品）が1つ</strong>手に入ることがあります。手に入らない場合、<strong>ステータス成長ボーナス</strong>が抽選されます。
        </p>

        <table class="guide-table">
          <thead>
            <tr><th>内容</th><th>通常モード</th><th>鬼畜モード</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>追加ステータス成長ボーナスの発生率</td>
              <td><span id="guideBossStatRateNormal">-</span></td>
              <td><span id="guideBossStatRateBrutal">-</span></td>
            </tr>
            <tr>
              <td>ボス戦利品（魔道具）</td>
              <td colspan="2">勝利時に<strong>最大1つ</strong></td>
            </tr>
          </tbody>
        </table>

        <h4 class="guide-h4">ボス戦利品の「修飾語（形容詞）」の絞り込み</h4>
        <p class="guide-paragraph">
          ボス戦利品は「中程度以上のレア寄り」を狙うため、形容詞は <code>dropRate ≤ <span id="guideBossAdjThreshold">-</span></code> の候補から選ばれます（実装どおり）。
        </p>
        <div class="guide-two-col">
          <div>
            <div class="guide-subtitle">ボス戦利品で選ばれる形容詞</div>
            <div id="guideBossAdjAllowed" class="guide-pillbox">-</div>
          </div>
          <div>
            <div class="guide-subtitle">ボス戦利品では選ばれにくい（除外される）形容詞</div>
            <div id="guideBossAdjExcluded" class="guide-pillbox">-</div>
          </div>
        </div>
        <div class="subnote">※色（例：虹色の）や名詞（例：箱）はボス戦利品でも通常どおり抽選されます。</div>
      </div>
    </details>

    <details class="guide-fold">
      <summary>新スキル習得率（動的表示）</summary>
      <div class="guide-fold-body">
        <p class="guide-paragraph">
          勝利後に、敵が持っていたスキルのうち未習得のものを「習得」できる抽選が行われます。確率はモードによって変わります。
        </p>

        <table class="guide-table">
          <thead>
            <tr><th>項目</th><th>表示</th></tr>
          </thead>
          <tbody>
            <tr><td>現在のモード</td><td><span id="guideModeNow">-</span></td></tr>
            <tr><td>現在の連勝数</td><td><span id="guideStreakNow">-</span></td></tr>
            <tr><td>（参考）現在の敵レアリティ係数</td><td><span id="guideEnemyRarityNow">-</span></td></tr>
            <tr><td>現在の計算結果（この条件なら）</td><td><strong><span id="guideSkillGainNow">-</span></strong></td></tr>
            <tr><td>計算式（実装どおり）</td><td><code id="guideSkillGainFormula">-</code></td></tr>
          </tbody>
        </table>

        <div class="subnote">
          ※鬼畜モードは固定値、通常モードは <code>敵レアリティ × 連勝数</code> に応じて上がる設計です（実装値を表示）。
        </div>
      </div>
    </details>
    </p>

		

		<h3>🎯 連勝数によるボーナス仕様</h3>
		<p>あなたの戦績が良いほど、スキルや報酬に有利な影響を与えます！</p>
		
		<h4>🔹 特殊スキルの性能上昇</h4>
		<ul>
		  <li>特殊スキルの <strong>発動率</strong> や <strong>特殊効果の効果値</strong> に、スキルレベルに応じたボーナス補正が加わります。</li>
		  <li>補正値は最大で <strong>+10%</strong> 程度。</li>
		  <li>強いプレイヤーほどレアスキルを得やすくなります。</li>
		</ul>
		
		<h4>💎 魔メイクのレア排出率UP</h4>
		<ul>
		  <li>魔メイクのレアランク（S〜B）の出現率が、現在の連勝数に応じて上昇します。</li>
		  <li>例：Dランクの割合が減少し、S〜Aランクの出現率がわずかに上昇。</li>
		</ul>
		
		<p style="color:#888; font-size: 90%;">
		※補正は控えめに設計されており、ゲームバランスを壊さず自然に反映されます。
		</p>

    <h3>ゲーム終了とスコア</h3>
    <p>
        タイトル画面では総戦闘回数を選択できます。指定した回数の戦闘を終えると、自動的にゲームが終了し、結果画面が表示されます。無制限を選んだ場合は終了がありません。<br>
        ゲーム終了時にはスコアが表示されます。スコアは最大連勝数・ステータス・所持魔道具の合計レアリティから算出され、最大HPは評価に含まれません。<br>
        ゲーム終了後、再度挑戦する場合はセーブボタンでデータを保存し、タイトルに戻って「つづきから」ボタンでゲームを開始してください。
    </p>
		
		<p>
    キャラクターを作り直したい場合は「はじめから」ボタンを押して新しいゲームを開始してください。<br><br>

    <strong style="color: #ff4444;">
			※重要：ゲームオーバー後には、成長は初期化されますが、<u>スキルメモリー、特殊スキルや魔道具は一部引き継がれます</u>。<br>
        継続的にプレイすることで、成長したスキルや貴重な魔道具を維持して次の攻略に活かせます。
    </strong>
</p>

    <h3>スキルメモリー</h3>
    <p>
        スキルは戦闘やイベントを通じて習得します。習得したスキルは「スキルメモリー」に記録され、発動率に影響する順番をドラッグで調整できます。<br>
        初期スキルは白色で表示され、それ以外の習得スキルは色付きで表示されます。パッシブスキル（補助効果）はゴールドで表示され、常時効果を発揮します。
    </p>
		
		<h3>特殊スキルについて</h3>
		
		<p>
		  特殊スキルとは、特殊効果を発動する強力なスキルです。<br>

		  <strong>複数の特殊スキルを所持している場合は、それぞれ特殊効果を発動可能</strong>です。
		</p>
		
		<p>
			特殊スキルの「特殊効果」はランダムで付与されており、確率で発動時に効果が発生します。<br>
		</p>
		
		<p>
		  <strong>特殊効果の例：</strong>
		  <ul>
		    <li>敵の残りHPに応じた追加ダメージ</li>
		    <li>戦闘不能時に一度だけ自動復活</li>
		    <li>継続ダメージを受けた際の即時回復</li>
		    <li>攻撃・防御・素早さ・最大HPの戦闘中バフ（スキルを持っているだけで常時発動）</li>
		  </ul>
		</p>
		
		<p>
		  特殊スキルは強力ですが、<strong>戦闘に敗北すると全て消滅</strong>します。<br>
		  ただし、<strong>1つだけ「保護」することが可能</strong>で、保護された特殊スキルはゲームオーバー後も保持されます。
		</p>
		
		<p>
		  保護設定は特殊スキルの一覧からスキル名を<strong>2回クリック</strong>することで行えます。<br>
		  既に別のスキルが保護されている場合は、そちらを<strong>明示的に解除しない限り新たな保護はできません</strong>。<br>
		  なお、<strong>保護された特殊スキルはレベルが成長しない</strong>ため、<strong>効果が物足りないと感じた場合は、新たに生成し直す</strong>のが現実的な選択肢となります。
		</p>
		
		<p>
		  特殊スキルは、生成時に使用したスキルのレベルに応じて初期レベルが決定されます。<br>
		  そのため、<strong>高レベルスキルを使って作り直せば、より強力な特殊スキルが得られる可能性があります</strong>。
		</p>
		
		<h3>特殊スキル名の構造</h3>
		<p>
		  特殊スキルの名前は、発動率・効果値に応じた<strong>2つの接頭語</strong>と、ランダムなカタカナ名で構成されています。<br>
		  これにより、<strong>スキル名を見るだけでレア度や性能の目安</strong>がわかるようになっています。
		</p>
		
		<p><strong>構成例：</strong><br>
		「<span style='color:#aaa;'>素早い</span> × <span style='color:#f39;'>煌めく</span> エリュシオン」<br>
		（発動率中程度／効果値が非常に高い）</p>
		
		<h4>発動率による接頭語例（一部）</h4>
		<table border="1" cellspacing="0" cellpadding="6">
		  <thead><tr><th>発動率（目安）</th><th>接頭語例</th></tr></thead>
		  <tbody>
		    <tr><td>75%〜80%</td><td>神速の、白銀の、刹那の</td></tr>
		    <tr><td>60%〜75%</td><td>軽快な、反応する、流星の</td></tr>
		    <tr><td>40%〜60%</td><td>普通の、揺れる、均衡の</td></tr>
		    <tr><td>20%〜40%</td><td>鈍い、停滞した、緩慢な</td></tr>
		    <tr><td>10%〜20%</td><td>錆びついた、眠たげな、遅い</td></tr>
		  </tbody>
		</table>
		
		<h4>効果値による接頭語例（一部）</h4>
		<table border="1" cellspacing="0" cellpadding="6">
		  <thead><tr><th>効果倍率／値</th><th>接頭語例</th></tr></thead>
		  <tbody>
		    <tr><td>4.5倍〜5.0倍以上<br>（または30%以上）</td><td>煌めく、烈火の、極彩の</td></tr>
		    <tr><td>3.5倍〜4.5倍</td><td>紅蓮の、深紅の、激しい</td></tr>
		    <tr><td>2.5倍〜3.5倍</td><td>やや強力な、重厚な、妖しい</td></tr>
		    <tr><td>1.5倍〜2.5倍</td><td>微細な、儚い、かすかな</td></tr>
		    <tr><td>1.0倍〜1.5倍未満</td><td>曇った、薄い、平凡な</td></tr>
		  </tbody>
		</table>
		
		<h4>視覚的なランク表示</h4>
		<ul>
		  <li>★の数や色でスキルの<strong>総合評価（S〜Dランク）</strong>が分かります</li>
		  <li>接頭語の組み合わせによって、スキルの<strong>強さ・発動しやすさ</strong>が直感的に把握できます</li>
		</ul>

    <h3>所持魔道具</h3>
    <p>
        特定条件下で入手できる魔道具は対応するスキル1つと結びついており、戦闘中に自動発動します。<br>
        使用回数・発動確率・破損率といった性能は、魔道具名を構成する以下の要素によって決まります。
    </p>
    <ul>
        <li><strong>色：</strong>1戦での使用可能回数（例：<span style="color: gold;">金色</span>は4回、<span style="color: lightgray;">透明</span>は無制限）</li>
        <li><strong>形容詞：</strong>スキル発動確率（例：「伝説の」魔道具なら発動率60%）</li>
        <li><strong>名詞：</strong>魔道具の壊れにくさ（例：「珠玉」なら壊れない、「勾玉」なら破損率0.1%）</li>
    </ul>
    <p>
        プレイヤーが同じスキルを所持していれば、そのレベルが魔道具発動時に反映されます。魔道具でスキルが発動するごとに、該当スキルのレベルが成長する可能性もあります。<br>
        <strong>魔道具保護機能：</strong>所持魔道具は<strong>最大3つまで</strong>保護可能です。保護された魔道具は削除や破損の対象になりません。魔道具名をタップ（クリック）すると「保護する／保護を外す／削除する」のメニューが表示されます（保護中の魔道具は削除できません）。
    </p>
		
		<h3>魔通貨と魔メイク</h3>
<p>
    ゲーム中に<strong>最高スコアの合計</strong>が高くなると、<strong>魔通貨</strong>を獲得できるようになります。スコアが高いほど魔通貨入手のチャンスが増えますが、1回で獲得できる魔通貨数は<strong>最大10枚まで</strong>です。スコアが合計40万の場合、おおよそ<strong>3枚程度</strong>獲得できるバランスになっています（毎回ランダムです）。<br>
    魔通貨は<strong>魔メイク</strong>に使用できます。
</p>
<p>
    魔メイクでは<strong>ランダムに魔メイク</strong>を1つ獲得します。魔メイクはステータス画面に表示される装飾用で、現在はSランク〜Dランクまでが存在します。入手した魔メイクは保持され、スコアや魔メイク収集の達成度にも影響を与えます。
</p>

<h3>モードの違い</h3>
<ul>
  <li>
    <strong>通常モード：</strong><br>
    敵は戦闘を重ねるごとに<strong>だんだん強く</strong>なっていきます（最初は弱く、後になるほど成長が加速します）。<br>
    ただし敵の<strong>スキルレベルは低め</strong>なので、スキルの威力は控えめです。<br>
    また、戦闘に勝つたびに発生する<strong>ステータスアップのイベントは、連勝を重ねると発生しにくく</strong>なります。
  </li>
  <br>
  <li>
    <strong>鬼畜モード：</strong><br>
    敵の強さは<strong>戦闘ごとに一定のペースで上昇</strong>します（毎戦確実に強くなります）。<br>
    さらに、<strong>敵のスキルレベルは高め</strong>で、1つひとつのスキルが強力です。<br>
    一方で、<strong>ステータスアップのイベントはほとんど発生しません</strong>。自キャラの成長は主にスキルや魔道具によって行われます。<br>
    <strong style="color:#ffd700;">魔道具は鬼畜モードでしか手に入りません！</strong>通常モードでは入手できないため、魔道具による戦略を使いたい場合は鬼畜モードを選びましょう。
  </li>
</ul>

    <h3>停止フィルター</h3>
    <p>
        魔道具入手時に、色・形容詞・名詞のいずれかが指定した条件に一致すると自動で戦闘が停止します。<br>
        条件はチェックボックスで自由に設定可能です。フィルターを設定しなくても魔道具は通常どおり入手できます。
    </p>

    <h3>補足</h3>
    <p>
        キャラクターのステータスや習得スキル、所持魔道具の詳細は画面上に随時表示されます。成長イベントやスキル削除イベントの発生状況、HPの推移なども可視化されています。<br>
        セーブ機能を使うことで進行状況を保存でき、強化したキャラクターで後日続きからプレイすることも可能です。セーブデータを活用し、さらに連勝記録を伸ばしていきましょう。
    </p>

    <h3>攻略のヒント</h3>
    <ul>
        <li><strong>スキル構成の再構築：</strong>増えたスキルの取捨選択が重要です。不要なスキルはスキル削除機能（残り使用回数に注意）で整理し、強力なスキルがより発動しやすい構成を目指しましょう。</li>
        <li><strong>連勝による敵の強化：</strong>敵は連勝を重ねるごとに強くなるため、油断せずキャラクターを強化し続ける必要があります。連勝が進むほど成長イベントで得られるステータス上昇量も増加するため、この機会に戦力を底上げしましょう。特に鬼畜モードでは敵の強化幅が大きい分、勝利時に得られる魔道具の活用が攻略の鍵となります。</li>
        <li><strong>スキルメモリーの活用：</strong>スキルメモリー内のスキル順序を工夫して、狙ったスキルが発動しやすいようにしましょう。</li>
    </ul>    <h3>データ一覧（折りたたみ）</h3>

    <details class="guide-details">
      <summary><b>🧰 魔道具の説明・数値一覧（色 / 形容詞 / 名詞）</b></summary>
      <div class="subnote">※中の数値は、ゲーム内の設定値から自動生成しています。</div>
      <div id="itemElementList"></div>
    </details>

    <details class="guide-details">
      <summary><b>📚 スキル効果一覧（簡易説明）</b></summary>
      <div class="subnote">※一覧は <code>skills.js</code> の定義から自動生成しています。</div>
      <div id="skillEffectList"></div>
    </details>

    <details class="guide-details">
      <summary><b>📐 スキル効果値一覧（パラメータ）</b></summary>
      <div class="subnote">※「倍率・確率・継続ターン」などの生データです。実際のダメージ/回復量は ATK/DEF/スキルLv 等で変動します。</div>
      <div id="skillValueList"></div>
    </details>
</div>
    </div>

    <!-- バトルエリア -->
<div id="battleArea" class="hidden">
	<div id="charInfoFold" class="quick-guide-content hidden">
<details open>
  <summary><strong>自分のキャラクター情報（スクロール可能）</strong></summary>
	
<!-- 魔メイクUIコンテナ（全幅表示・透過背景） -->
<div id="faceMemoryUI" style="
  width: 100%;
	
  color: #fff;
  border: none;
  box-shadow: none;
  border-radius: 0;
  animation: fadeIn 0.6s ease-out;
">

  <!-- 表示切替ボタン（スタイル統一） -->
  <button id="faceMemoryToggle" style="
    font-size: 11px;

    background: linear-gradient(to bottom, #222, #444);
    color: #0ff;
    border: 1px solid #0ff;
    border-radius: 4px;
    cursor: pointer;
    text-shadow: 1px 1px 0 #000;
    transition: background 0.2s ease, transform 0.1s ease;
  ">
    ▶ 魔メイクを表示
  </button>

  <!-- 折りたたみ可能なコンテンツ -->
  <div id="faceMemoryContent" style="display: none; margin-top: 10px;">
    <!-- 魔通貨と魔メイク -->
    <div id="faceCoinInfo" style="margin-bottom: 10px;">
      魔通貨: <span id="faceCoinCount">0</span> 枚 
		<button id="faceGachaBtn" disabled>ガチャ</button>
		
		<br>
		
		<div class="subnote">※現在の連勝数が多いほど高レア排出率UP</div>
			
			
    </div>

    <!-- 所持魔メイク一覧 -->
    <div id="ownedFaceList"></div>
  </div>
</div>

  <div id="uniqueSkillSection" >
    <button id="toggleUniqueSkills" style="
		  height: 36px;
      font-size: 11px;
      padding: 4px 6px;
      background: linear-gradient(to bottom, #222, #444);
      color: #0ff;
      border: 1px solid #0ff;
      border-radius: 4px;
      cursor: pointer;
      text-shadow: 1px 1px 0 #000;
      transition: background 0.2s ease, transform 0.1s ease;
    ">
      ▶ 固有スキル候補を表示
    </button>
    <ul id="uniqueSkillList" style="
      display: none;
      list-style: none;
      padding-left: 0;

    "></ul>
		
		
  </div>

    <div class="status-area compact">
      <div class="char-info">

<canvas id="playerCanvas" width="64" height="64"></canvas>
      </div>
      <div class="stats-container" id="playerStats">
        <p id="atkStat">ATK: 0</p>
        <p id="defStat">DEF: 0</p>
        <p id="spdStat">SPD: 0</p>
        <p id="hpStat">HP: 0</p>
        <p id="maxHpStat">MAX HP: 0</p>
				
    </div>
  </div>
</details>
	

  <details open>
    <summary><strong>敵のキャラクター情報（スクロール可能）</strong></summary>
    <div class="status-area compact">
      <div class="char-info">
        <canvas id="enemyCanvas" width="64" height="64"></canvas>
        <!-- 強敵用魔メイク画像（通常時は非表示） -->
        <img id="enemyImg" class="hidden" alt="Enemy Face">
      </div>
      <div class="stats-container" id="enemyStats"></div>
    </div>
  </details>
</div>
</div>

      <!-- 戦闘ログ -->
		<div class="quick-guide-wrapper">
			<div id="quickGuideLog" class="quick-guide-content hidden">
          
          <div id="battleLogControls" class="battle-log-controls">
            <div class="battle-log-speed">
              <label for="logSpeedSlider">ログ速度</label>
              <input id="logSpeedSlider" type="range" min="5" max="200" step="1" value="20" />
              <span id="logSpeedValue" class="battle-log-speed-value">20ms</span>
            </div>
            <div class="battle-log-accel">
              <span class="battle-log-accel-label">加速度</span>
              <div class="battle-log-accel-buttons">
                <button type="button" id="logAccelBtn0" class="log-accel-btn">OFF</button>
                <button type="button" id="logAccelBtn1" class="log-accel-btn">弱</button>
                <button type="button" id="logAccelBtn2" class="log-accel-btn">強</button>
              </div>
            </div>
          </div>

<pre id="battleLog" style="height:350px;"></pre>
        </div>
      </div>


						
			
      <!-- モード切替 -->
      <button id="specialModeButton" class="normal-mode" onclick="toggleSpecialMode()">通常モード</button>
      <!-- バトル操作 -->
			<!--<button id="startBattleOnceBtn" class="normal-mode">単発バトル</button>-->
      <button id="startBattleBtn" class="normal-mode">バトル！</button>
      <!-- <button id="mixedEffectListBtn" class="normal-mode">混合効果一覧</button>-->
			<div class="subnote">※戦闘ログ表示推奨。バトルボタン長押しで連戦可能。</div>
			<canvas id="hpChart" width="600" height="100"></canvas>



<!-- ゲーム終了時の結果表示ボックス（画面中央に表示） -->
<div id="finalResults" 
     style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
            background:#333; color:#fff; padding:20px; border:2px solid #fff; z-index:10000; max-width:300px;">
  <!-- 最終結果はJavaScriptで埋め込まれます -->
	
</div>
<!-- 折りたたみ可能なスキル・魔道具メモリーセクション -->
<div id="memoryToggleContainer">
<div id="memoryContent" class="hidden" style="margin-top: 10px;">

		
<!-- 特殊スキル -->
<h4>特殊スキル</h4>
<div class="subnote">※選択で保護 / 解除可能</div>
<div id="combinedSkillContainer">
  <ul id="combinedSkillList"></ul>
</div>

<!-- 所持魔道具 -->
<h4>所持魔道具</h4>
<div class="subnote">※選択で3つまで保護 / 解除可能</div>
<div id="itemMemoryContainer">
  <ul id="itemMemoryList"></ul>
</div>

<!-- スキルメモリー -->
<h4>スキルメモリー</h4>
<div class="subnote">※3つ選択して最上部へ移動可能。スキル再構成時、上から数件を選出。</div>
<div id="skillMemoryContainer" style="display: block;">
  <ul id="skillMemoryList"></ul>
</div>


			

			

      <label>同時発動スキル数（通常モードのみ）:
        <select id="skillSimulCountSelect">
          <option value="1">1個</option>
          <option value="2" selected>2個</option>
          <option value="3">3個</option>
          <option value="4">4個</option>

        </select>
      </label>
			
			

		
		

  </div>
</div>
		

<div id="eventSettingsToggleContainer">
<div id="eventSettingsContent" class="hidden" style="margin-top: 10px;">

    <h4>イベント設定</h4>
    <div id="autoStopControls">
      <button id="toggleGrowthEvents" class="toggle-btn">成長イベント: 発生</button>
      <button id="toggleSkillDeleteEvents" class="toggle-btn">スキル削除イベント: 発生</button>
      <button id="toggleItemInterrupt" class="toggle-btn">魔道具入手: 進行を停止する</button>
    </div>

    <h4 style="margin-top: 20px;">魔道具入手時設定</h4>
    <div style="margin-bottom: 10px;">
      <button id="filterModeToggleBtn" class="toggle-mode-btn and">各要素の条件を満たす</button>
    </div>

    <div id="itemFilterBox" class="styled-filter-box">
      <details><summary><b>要素1 色で停止</b></summary><div id="filterColorOptions"></div></details>
      <details><summary><b>要素2 修飾語で停止</b></summary><div id="filterAdjectiveOptions"></div></details>
      <details><summary><b>要素3 名詞で停止</b></summary><div id="filterNounOptions"></div></details>
    </div>

  </div>
</div>





    <!-- 設定（折りたたみ） -->
	<div id="settingsFold" class="quick-guide-content hidden">
  <div class="panel-grid">

		      <button id="downloadLogsBtn">バトルログ出力</button>
     <!--   <div id="saveControls">
      <button id="saveCodeBtn">セーブ</button>
      <input type="text" id="saveCodeBox" readonly /> -->
<button id="toggleAutoSave" class="toggle-btn off">自動保存: OFF（10戦ごと）</button>
<button id="exportSaveTxtBtn" onclick="exportSaveAsTextFile()">セーブデータをテキスト出力</button>
<input type="text" id="saveCodeBox" readonly style="position:absolute; left:-9999px; top:-9999px; width:1px; height:1px; opacity:0;" />

			
<button id="localSaveBtn" onclick="saveToLocalStorage()">ローカルにセーブ（未保存）</button>
<button id="localProgressSaveBtn" onclick="localProgressSaveMirror()">※戦闘数進捗を含む中断セーブはこちら</button>
<button id="returnToTitleBtnInGame" style="

  padding: 6px 12px;
  font-size: 13px;
  font-weight: bold;
  background-color: #0066cc;
  color: #fff;
  border: 2px solid #004c99;
  border-radius: 6px;
  cursor: pointer;
  text-shadow: 1px 1px 2px #000;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
">
  タイトルに戻る
</button>
  </div>
</div>

    </div>

  </div>
    </div>
		
<div id="subtitleOverlay" style="
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(30, 30, 30, 0.85);
  color: #fff;
  padding: 8px 20px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: bold;
  box-shadow: 0 0 8px rgba(0,0,0,0.4);
  z-index: 9998;
  display: none;
  max-width: 80%;
  width: fit-content;
  text-align: center;
  pointer-events: none;
  white-space: normal;
  line-height: 1.4;
"></div>

<div id="itemOverlay" style="display: none;"></div>

  <!-- スクリプト読込 -->
  <script type="module" src="game.js" ></script>
	
<div id="gachaAnimation" style="display: none;">
  <div class="gacha-body">
    <div class="gacha-glass">
      <div class="gacha-ball"></div>
    </div>
    <div class="gacha-knob"></div>
  </div>
</div>

<!-- イベントポップアップ -->
<div id="eventPopup" style="
  display: none;
	position: absolute; 
  top: 30%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(34,34,34,0.95);
  color: #fff;
  padding: 20px;
  border: 2px solid #fff;
  border-radius: 8px;
  box-shadow: 0 0 10px #fff;
  z-index: 2147483647; /* 最大の前面値 */
  text-align: center;
  max-width: 90%;
  pointer-events: auto;
">
  <h3 id="eventPopupTitle"></h3>
  <div id="eventPopupOptions" style="margin-top: 10px;"></div>
  <div id="eventPopupSelectContainer" style="margin-top:10px; display:none;">
    <select id="eventPopupSelect"></select>
    <button id="eventPopupSelectBtn">決定</button>
  </div>
</div>

<script>
	
// updateNotice は構成によって存在しない場合があるため、ある時だけバインドする
(function(){
  var _updateNotice = document.getElementById("updateNotice");
  if (_updateNotice) {
    _updateNotice.addEventListener("click", function() {
      this.style.display = "none";
    });
  }
})();

// ======================================================
// 単発バトル：一時表示トースト（重複完全抑止・位置をさらに下へ）
// ======================================================
(function(){
  if (window.__onceToastInitV2) return;
  window.__onceToastInitV2 = true;

  // removed early increment to avoid NaN
  window.singleBattleUsed = (window.singleBattleUsed|0);

  function modeKey(){ return (window.specialMode === 'brutal') ? 'brutal' : 'normal'; }
  function modeLabel(){ return (window.specialMode === 'brutal') ? '鬼畜' : '通常'; }
  function getUsed(){ return (window.singleBattleUsed|0); }
  function setUsed(v){ window.singleBattleUsed = (v|0); }

  // —— トースト（1個だけ再利用・同時重複なし）——
  var toastHost = null;
  var toastEl   = null;
  var toastTimer = null;
  var lastToastStamp = 0;

  function ensureToastHost(){
    if (toastHost) return toastHost;
    toastHost = document.createElement('div');
    toastHost.id = 'onceToastHost';
    toastHost.style.position = 'fixed';
    // iPhoneノッチを考慮しつつ、さらに下へ：84px（調整可）
    toastHost.style.top = 'calc(env(safe-area-inset-top, 0px) + 450px)';
    toastHost.style.right = '12px';
    toastHost.style.zIndex = '99999';
    toastHost.style.pointerEvents = 'none';
    document.body.appendChild(toastHost);
    return toastHost;
  }

  // ---- トースト表示（右上少し下・黒い磨りガラス風） ----
  function showOnceToast(message, ms){
    ms = ms || 1400;

    var now = Date.now();
    if (now - lastToastStamp < 80) return;
    lastToastStamp = now;

    ensureToastHost();

    if (!toastEl){
      toastEl = document.createElement('div');
      toastEl.id = 'onceToastBubble';
      toastEl.style.pointerEvents = 'auto';
      // 🎨 見た目：黒い磨りガラス風
      toastEl.style.background = 'rgba(20, 20, 25, 0.55)';
      toastEl.style.backdropFilter = 'blur(8px) saturate(120%)';
      toastEl.style.webkitBackdropFilter = 'blur(8px) saturate(120%)';
      toastEl.style.border = '1px solid rgba(255,255,255,0.1)';
      toastEl.style.borderRadius = '12px';
      toastEl.style.padding = '10px 14px';
      toastEl.style.fontSize = '14px';
      toastEl.style.lineHeight = '1.3';
      toastEl.style.color = '#fff';
      toastEl.style.textShadow = '0 0 2px rgba(0,0,0,0.4)';
      toastEl.style.boxShadow = '0 6px 18px rgba(0,0,0,.35)';
      toastEl.style.opacity = '0';
      toastEl.style.transform = 'translateY(-8px)';
      toastEl.style.transition = 'opacity 220ms ease, transform 220ms ease';
      toastHost.appendChild(toastEl);
    }

    if (toastTimer) { clearTimeout(toastTimer); toastTimer = null; }
    toastEl.textContent = message;

    // アニメ開始
    toastEl.style.opacity = '0';
    toastEl.style.transform = 'translateY(-8px)';
    requestAnimationFrame(() => {
      toastEl.style.opacity = '1';
      toastEl.style.transform = 'translateY(0)';
    });

    // フェードアウト（DOM保持）
    toastTimer = setTimeout(() => {
      toastEl.style.opacity = '0';
      toastEl.style.transform = 'translateY(-8px)';
    }, ms);
  }

  function updateOnceBtnVisibility(){
  var btn = document.getElementById('startBattleOnceBtn');
  if (!btn) return;
  var u = (typeof getUsed === 'function') ? getUsed() : (typeof used === 'function' ? used() : 0);
  btn.disabled = (u >= window.ONCE_LIMIT);
  btn.style.display = '';
}


  // —— 単発クリックのキャプチャ・重複完全抑止 —— 
  function guardOnceClick(e){
    var t = e.currentTarget;
    if (!t || t.id !== 'startBattleOnceBtn') return;

    var used = getUsed();
    if (used >= window.ONCE_LIMIT){
      e.stopImmediatePropagation();
      e.preventDefault();

      updateOnceBtnVisibility();
      return;
    }

    if (e.__onceCountedV2) return;       // 同一クリック重複防止（再入保護）
    e.__onceCountedV2 = true;

    setUsed(used + 1);
    var remain = Math.max(0, window.ONCE_LIMIT - getUsed());
    showOnceToast(`単発バトル 残り ${remain}/${window.ONCE_LIMIT}（${modeLabel()}）`, 1200);

    if (getUsed() >= window.ONCE_LIMIT){
      setTimeout(updateOnceBtnVisibility, 0);
    }
  }

  function bindGuard(){
    var btn = document.getElementById('startBattleOnceBtn');
    if (!btn || btn.__onceLimitGuardV2) return;
    btn.__onceLimitGuardV2 = true;
    btn.addEventListener('click', guardOnceClick, true); // capture
  }

  // —— モード切替・新規開始 —— 
  if (typeof window.startNewGame === 'function'){
    var _origStartNewGame = window.startNewGame;
    window.startNewGame = function(){
      window.singleBattleUsed = 0;
      setTimeout(function(){
        updateOnceBtnVisibility();
        bindGuard();

      }, 0);
      return _origStartNewGame.apply(this, arguments);
    };
  }
  if (typeof window.toggleSpecialMode === 'function'){
    var _origToggle = window.toggleSpecialMode;
    window.toggleSpecialMode = function(){
      var prev = modeKey();
      var ret = _origToggle.apply(this, arguments);
      var now = modeKey();
      if (now !== prev){
        setTimeout(function(){
  updateOnceBtnVisibility();
  bindGuard && bindGuard();
  try{
    var remain = Math.max(0, window.ONCE_LIMIT - (typeof getUsed==='function'?getUsed():0));
    showOnceToast(`モード切替：${modeLabel()}（単発 残り ${remain}/${window.ONCE_LIMIT}）`, 1100);
  }catch(_e){}
}, 0);

      }
      return ret;
    };
  }

  function init(){
    bindGuard();
    updateOnceBtnVisibility();
    ensureToastHost(); // 初回にホストだけ用意（位置ぶれ防止）
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  setTimeout(init, 0);   // 遅延ロード保険（再バインドはフラグで回避）
})();

</script>
</div>


<!-- === Once Limit Reactive Refresh (V3) === -->
<script>
(function(){
  if (window.__onceButtonFixV3) return;
  window.__onceButtonFixV3 = true;

  function getOnceLimit(){
    var v = (typeof window.ONCE_LIMIT === 'number') ? window.ONCE_LIMIT : (window.ONCE_LIMIT|0);
    if (!Number.isFinite(v)) v = 20;
    return v;
  }
  function getUsedSafe(){
    try { return (typeof getUsed==='function') ? (getUsed()|0) : (window.singleBattleUsed|0); }
    catch(_){ return (window.singleBattleUsed|0); }
  }

  // 見た目と操作性を完全に復旧
  window.updateOnceBtnVisibility = function(){
    var btn = document.getElementById('startBattleOnceBtn');
    if (!btn) return;
    var remain = Math.max(0, getOnceLimit() - getUsedSafe());
    var enable = (remain > 0);
    btn.disabled = !enable;
    btn.classList.toggle('disabled', !enable);
    // 一部テーマの pointer-events やフィルタが残らないよう保険
    if (enable) {
      btn.style.pointerEvents = '';
      btn.style.filter = '';
      btn.style.opacity = '';
    }
  };

  window.refreshOnceBtn = function(){
    try { window.updateOnceBtnVisibility(); } catch(_){}
  };

  // 画面復帰・可視化時に再評価（モバイルSafari等の対策）
  window.addEventListener('focus', window.refreshOnceBtn);
  document.addEventListener('visibilitychange', function(){
    if (!document.hidden) window.refreshOnceBtn();
  });

  // 軽いポーリングで取りこぼしを救う（800ms）
  setInterval(function(){ window.refreshOnceBtn(); }, 800);

  // 外部からもイベントで再評価可能
  window.addEventListener('onceLimitChanged', window.refreshOnceBtn);

  // 初回評価
  window.refreshOnceBtn();
})();
</script>


<script>
// Ensure shared single-battle usage counter and helpers exist & are numeric
(function(){
  try{
    if (!Number.isFinite(window.ONCE_LIMIT)) window.ONCE_LIMIT = 10;
    if (!Number.isFinite(window.singleBattleUsed)) window.singleBattleUsed = 0;
    if (typeof window.getUsed !== 'function') {
      window.getUsed = function(){ return (window.singleBattleUsed|0); };
    } else {
      // Wrap to coerce return to integer
      var __origGetUsed = window.getUsed;
      window.getUsed = function(){ try{ return (__origGetUsed()|0); }catch(_){ return (window.singleBattleUsed|0); } };
    }
    if (typeof window.setUsed !== 'function') {
      window.setUsed = function(v){ window.singleBattleUsed = (v|0); };
    }
  }catch(e){}
})();
</script>


<!-- === Once Limit Refresh & NaN Guard (V4) === -->
<script>
(function(){
  if (window.__onceButtonFixV4) return;
  window.__onceButtonFixV4 = true;

  function getOnceLimit(){
    var v = (typeof window.ONCE_LIMIT === 'number') ? window.ONCE_LIMIT : (window.ONCE_LIMIT|0);
    if (!Number.isFinite(v)) v = 20;
    return v|0;
  }
  function getUsedSafe(){
    try { return (typeof getUsed==='function') ? (getUsed()|0) : (window.singleBattleUsed|0); }
    catch(_){ return (window.singleBattleUsed|0); }
  }

  // Replace/augment updateOnceBtnVisibility to be NaN-safe
  var _origUpdateOnce = window.updateOnceBtnVisibility;
  window.updateOnceBtnVisibility = function(){
    var btn = document.getElementById('startBattleOnceBtn');
    if (!btn) return;
    var remain = Math.max(0, getOnceLimit() - getUsedSafe());
    var enable = (remain > 0);

    btn.disabled = !enable;
    btn.classList.toggle('disabled', !enable);
    if (enable) {
      // clear any theme side-effects
      btn.style.pointerEvents = '';
      btn.style.filter = '';
      btn.style.opacity = '';
    }
    // Call original if it exists (in case it does extra UI work)
    try{ if (typeof _origUpdateOnce === 'function') _origUpdateOnce(); }catch(_){}
  };

  // Public hook
  window.refreshOnceBtn = function(){ try{ window.updateOnceBtnVisibility(); }catch(_){} };

  // When page regains focus/visibility
  window.addEventListener('focus', window.refreshOnceBtn);
  document.addEventListener('visibilitychange', function(){
    if (!document.hidden) window.refreshOnceBtn();
  });

  // Lightweight polling to avoid missed updates
  setInterval(function(){ window.refreshOnceBtn(); }, 800);

  // React to custom event
  window.addEventListener('onceLimitChanged', window.refreshOnceBtn);

  // Initial evaluation
  window.refreshOnceBtn();
})();
</script>

</body>
</html>